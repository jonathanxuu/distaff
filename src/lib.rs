#![no_std]
use log::debug;
use sp_std::{ops::Range, vec, vec::Vec};
use serde::{Serialize, Deserialize};
use sha2::{Digest, Sha256};

#[macro_use]
extern crate alloc;
use alloc::string::String;
use rand::prelude::*;
use rand::distributions::Uniform;
// RE-EXPORTS
// ================================================================================================
pub mod crypto;
pub mod math;
pub mod utils;

mod stark;
pub use stark::{ StarkProof, ProofOptions, GenOutput, ProgramAssembly };
mod processor;
pub use processor::{ OpCode, OpHint };

mod programs;
pub use programs::{ Program, ProgramInputs, assembly, blocks };


extern crate console_error_panic_hook;

extern crate wasm_bindgen;
use wasm_bindgen::prelude::*;
use blocks::{ ProgramBlock, Span, Group, Switch, Loop };

extern crate web_sys;
use wasm_bindgen_test::*;
use codec::{Decode, Encode};
use crate::alloc::string::ToString;

pub fn verify(program_hash: &[u8; 32], public_inputs: &[u128], outputs: &[u128], proof: &StarkProof) -> Result<bool, String>
{
    return stark::verify(program_hash, public_inputs, outputs, proof);
}

// EXECUTOR
// ================================================================================================

/// Executes the specicied `program` and returns the result together with a STARK-based proof of execution.
/// 
/// * `inputs` specifies the initial stack state and provides secret input tapes;
/// * `num_outputs` specifies the number of elements from the top of the stack to be returned;
#[wasm_bindgen]
pub fn starks_proofgen(program_string: String, inputs_string: String, num_outputs: usize, options_string: String) -> String
{
    let program_slice: &str = &program_string[..];
    console_log!("program is {:?}",program_slice);
    let program: Program = serde_json::from_str(program_slice).unwrap();

    let inputs_slice: &str = &inputs_string[..];
    let inputs: ProgramInputs = serde_json::from_str(inputs_slice).unwrap();

    let options_slice: &str = &options_string[..];
    let options: ProofOptions = serde_json::from_str(options_slice).unwrap();

    let secret_input = inputs.get_secret_inputs();
    let secret_inputa = &secret_input[0];
    let mut secret_hash = String::new();
    let Separator = String::from(",");
    let mut k = 0;
    for &i in secret_inputa {
        let mut hasher = Sha256::new();
        hasher.update(i.to_string().as_bytes());
        let mut result = hasher.finalize();

        let res = format!("{:x}", result);

        let mut hasher2 = Sha256::new();
        hasher2.update(res.as_bytes());
        let mut result2 = hasher2.finalize();


        secret_hash = secret_hash.clone() + &format!("{:x}", result2);
        if k + 1 < secret_inputa.len(){
            secret_hash = secret_hash.clone() + &Separator;
            k = k + 1 ;
        }else{
            secret_hash = secret_hash.clone();
        }
    }

    // console_log!("program is {:?},inputs is {:?},num is {:?},options is {:?}",serde_json::to_string(&program).unwrap(),serde_json::to_string(&inputs).unwrap(),serde_json::to_string(&num_outputs).unwrap(),serde_json::to_string(&options).unwrap());

    assert!(num_outputs <= MAX_OUTPUTS, 
        "cannot produce more than {} outputs, but requested {}", MAX_OUTPUTS, num_outputs);

    // execute the program to create an execution trace
    let (trace, ctx_depth, loop_depth) = processor::execute(&program, &inputs);
    // console_log!("trace vecvec is {:?}",trace);

    // console_log!("trace is {:?},ctx_depth is {:?}.loop_depth is {:?}",trace, ctx_depth,loop_depth);
    let mut trace = stark::TraceTable::new(trace, ctx_depth, loop_depth, options.extension_factor());
    debug!("Generated execution trace of {} registers and {} steps",
        trace.register_count(),
        trace.unextended_length());

    // copy the user stack state the the last step to return as output
    let last_state = trace.get_last_state();
    let outputs = last_state.user_stack()[..num_outputs].to_vec();

    // make sure number of executed operations was sufficient
    assert!(last_state.op_counter() as usize >= MIN_TRACE_LENGTH,
        "a program must consist of at least {} operation, but only {} were executed",
        MIN_TRACE_LENGTH,
        last_state.op_counter());

    // make sure program hash generated by the VM matches the hash of the program
    let program_hash = utils::as_bytes(last_state.program_hash());
    assert!(program.hash() == program_hash,
        "expected program hash {} does not match trace hash {}",
        hex::encode(program.hash()),
        hex::encode(program_hash));
    // console_log!("outputssss = {:?}",outputs);
    console_log!("hash = {:?}",hex::encode(program.hash()));
    // generate STARK proof
    // console_log!("trace is {:?},inuts.public is {:?}. outoupts is {:?}. option is {:?}",serde_json::to_string(&trace).unwrap(),inputs.get_public_inputs(),outputs,serde_json::to_string(&options).unwrap());

    // console_log!("prooooooooof is {:?}",serde_json::to_string(&proof).unwrap());
    let proof = stark::prove(&mut trace, inputs.get_public_inputs(), &outputs, &options);

    let proof_bytes = bincode::serialize(&proof).unwrap();
    let proof_hex_res = hex::encode(&proof_bytes);
    let gen_output = GenOutput{
        stark_output: outputs,
        stark_proof: proof_hex_res,
        secret_hash: secret_hash,
    };
    let res = serde_json::to_string(&gen_output).unwrap();

    return res;
}


pub fn verifylib(program_hash: &[u8; 32], public_inputs: &[u128], outputs: &[u128], proof: &StarkProof) -> Result<bool, String>
{
    return stark::verify(program_hash, public_inputs, outputs, proof);
}

#[wasm_bindgen]
pub fn starks_proofgen_with_program_name(program_name: String, inputs_string: String, num_outputs: usize, options_string: String) -> String
{

    let mut program_string = String::from("Wrong program name");

    match &program_name as &str {
        "number_over_20" => {program_string = generate_program(String::from("begin push.20 read gt.128 end"));},
        _ => {panic!("Wrong program name!!")}
    }
    let program_slice: &str = &program_string[..];
    let program: Program = serde_json::from_str(program_slice).unwrap();

    let inputs_slice: &str = &inputs_string[..];
    let inputs: ProgramInputs = serde_json::from_str(inputs_slice).unwrap();

    let options_slice: &str = &options_string[..];
    let options = ProofOptions::default();

    let secret_input = inputs.get_secret_inputs();
    let secret_inputa = &secret_input[0];
    let mut secret_hash = String::new();
    let Separator = String::from(",");
    let mut k = 0;
    for &i in secret_inputa{
        let mut hasher = Sha256::new();
        hasher.update(i.to_string().as_bytes());
        let mut result = hasher.finalize();

        let res = format!("{:x}", result);

        let mut hasher2 = Sha256::new();
        hasher2.update(res.as_bytes());
        let mut result2 = hasher2.finalize();

        secret_hash = secret_hash.clone() + &format!("{:x}", result2);
        if k + 1 < secret_inputa.len(){
            secret_hash = secret_hash.clone() + &Separator;
            k = k + 1 ;
        }else{
            secret_hash = secret_hash.clone();
        }
    }

    assert!(num_outputs <= MAX_OUTPUTS, 
        "cannot produce more than {} outputs, but requested {}", MAX_OUTPUTS, num_outputs);

    // execute the program to create an execution trace
    let (trace, ctx_depth, loop_depth) = processor::execute(&program, &inputs);
    console_log!("trace vecvec is {:?}",trace);

    let mut trace = stark::TraceTable::new(trace, ctx_depth, loop_depth, options.extension_factor());
    debug!("Generated execution trace of {} registers and {} steps",
        trace.register_count(),
        trace.unextended_length());

    // copy the user stack state the the last step to return as output
    let last_state = trace.get_last_state();
    let outputs = last_state.user_stack()[..num_outputs].to_vec();

    // make sure number of executed operations was sufficient
    assert!(last_state.op_counter() as usize >= MIN_TRACE_LENGTH,
        "a program must consist of at least {} operation, but only {} were executed",
        MIN_TRACE_LENGTH,
        last_state.op_counter());

    // make sure program hash generated by the VM matches the hash of the program
    let program_hash = utils::as_bytes(last_state.program_hash());
    assert!(program.hash() == program_hash,
        "expected program hash {} does not match trace hash {}",
        hex::encode(program.hash()),
        hex::encode(program_hash));
    // console_log!("hash = {:?}",hex::encode(program.hash()));

    // generate STARK proof
    let proof = stark::prove(&mut trace, inputs.get_public_inputs(), &outputs, &options);

    let proof_bytes = bincode::serialize(&proof).unwrap();
    let proof_hex_res = hex::encode(&proof_bytes);
    let gen_output = GenOutput{
        stark_output: outputs,
        stark_proof: proof_hex_res,
        secret_hash: secret_hash,
    };
    let res = serde_json::to_string(&gen_output).unwrap();

    return res;


}

#[wasm_bindgen]
pub fn generate_program( program_in_assembly: String ) -> String{
    let program :Program = assembly::compile(&program_in_assembly).unwrap();

    let serialized = serde_json::to_string(&program).unwrap();
    
    return serialized;
}

#[wasm_bindgen]
pub fn generate_program_hash( program_in_assembly: String ) -> String{
    let program :Program = assembly::compile(&program_in_assembly).unwrap();
    let hash = program.hash();
    let prefix = String::from("0x");
    let res = prefix +&hex::encode(hash);

    return res;
}


#[wasm_bindgen]
pub fn output_program_string() -> String{
    let program = assembly::compile("
    begin
        push.20 read gt.128
    end").unwrap();
    let serialized = serde_json::to_string(&program).unwrap();
    return serialized;
}


#[wasm_bindgen]
pub fn output_inputs_string( public_a: String, secret_a: String, secret_b: String) -> String {
    let mut public_aa = vec![];
    let mut numbers_a = vec![];
    let mut numbers_b = vec![];

    if public_a.len() != 0{ 
        let public_a: Vec<&str> = public_a.split(',').collect();
        public_aa= public_a
        .iter()
        .map(|public_a| public_a.parse::<u128>().unwrap())
        .collect();
    };

    if secret_a.len() != 0{
        let secret_a: Vec<&str> = secret_a.split(',').collect();
        numbers_a = secret_a
        .iter()
        .map(|secret_a| secret_a.parse::<u128>().unwrap())
        .collect();
    };

    if secret_b.len() != 0 {
        let secret_b: Vec<&str> = secret_b.split(',').collect();
         numbers_b = secret_b
        .iter()
        .map(|secret_b| secret_b.parse::<u128>().unwrap())
        .collect(); 
    };
    let inputs = ProgramInputs::new(&public_aa, &numbers_a, &numbers_b);
    let serialized = serde_json::to_string(&inputs).unwrap();
    return serialized;
}

#[wasm_bindgen]
pub fn output_option_string() -> String{
    let options = ProofOptions::default();
    let serialized = serde_json::to_string(&options).unwrap();
    return serialized;

}

#[wasm_bindgen]
pub fn hashtest(res: String) -> String
{
    let mut hasher = Sha256::new();
    hasher.update(res.as_bytes());
    let result = hasher.finalize();
    return format!("{:x}",result);

}

#[wasm_bindgen]
pub fn init_panic_hook() {
    console_error_panic_hook::set_once();

}



// pub fn main_test() {
//     log::trace!(
//         target: "starks-proofgen",
//         "This is a program to generate proof for 'Number over 20', please enter a number to be verified:
//         We choose 24 for you as a test. ",    
//     );

//     let number_to_be_verified: u128 = 24;

//     let inputs = ProgramInputs::new(&[], &[number_to_be_verified as u128], &[]);
//     let num_outputs = 1;
//     let expected_result = vec![if_over_twen(number_to_be_verified as u128)];
//     let options = ProofOptions::default();
//     let program = assembly::compile("
//     begin
//         push.20 read gt.128
//     end").unwrap();

//     log::trace!(
//         target: "starks-proofgen",
//         "This is a program to proof your number is over 20 or not ; expected result: {:?}" ,
//         expected_result , 
//     );


//     // execute the program and generate the proof of execution
//     let (outputs, proof) = starks_proofgen(&program, &inputs, num_outputs, &options);
//     // println!("--------------------------------");
//     log::trace!(
//         target: "starks-proofgen",
//         "Executed program with hash 0x{},Program output: {:?}" ,
//         hex::encode(program.hash()),outputs,
//     );

//     assert_eq!(expected_result, outputs, "Program result was computed incorrectly");
//     // serialize the proof to see how big it is
    
//     let proof_bytes = bincode::serialize(&proof).unwrap();
//     let _proof_hex = hex::encode(&proof_bytes);
//     // println!("proof_hex is {:?}",proof_hex);
    
//     log::trace!(
//         target: "starks-proofgen",
//         "Execution proof size: {} KB,Execution proof security: {} bits" ,
//         proof_bytes.len() / 1024, options.security_level(true),
//     );
// }

// fn if_over_twen(value: u128) -> u128{
//     log::trace!(
//         target: "starks-proofgen",
//         "your number is {:?}",
//         value,
//     );

//     if value > 20{
//         return 1;
//     }else{
//         return 0;
//     }
// }






// GLOBAL CONSTANTS
// ================================================================================================

pub const MAX_CONTEXT_DEPTH : usize = 16;
pub const MAX_LOOP_DEPTH    : usize = 8;
const MIN_TRACE_LENGTH      : usize = 16;
const MAX_REGISTER_COUNT    : usize = 128;
const MIN_EXTENSION_FACTOR  : usize = 16;
const BASE_CYCLE_LENGTH     : usize = 16;

const MIN_STACK_DEPTH       : usize = 8;
const MIN_CONTEXT_DEPTH     : usize = 1;
const MIN_LOOP_DEPTH        : usize = 1;

// PUSH OPERATION
// ------------------------------------------------------------------------------------------------
const PUSH_OP_ALIGNMENT     : usize = 8;

// HASH OPERATION
// ------------------------------------------------------------------------------------------------
const HASH_STATE_RATE       : usize = 4;
const HASH_STATE_CAPACITY   : usize = 2;
const HASH_STATE_WIDTH      : usize = HASH_STATE_RATE + HASH_STATE_CAPACITY;
const HASH_NUM_ROUNDS       : usize = 10;
const HASH_DIGEST_SIZE      : usize = 2;

// OPERATION SPONGE
// ------------------------------------------------------------------------------------------------
const SPONGE_WIDTH          : usize = 4;
const PROGRAM_DIGEST_SIZE   : usize = 2;
const HACC_NUM_ROUNDS       : usize = 14;

// DECODER LAYOUT
// ------------------------------------------------------------------------------------------------
//
//  ctr ╒═════ sponge ══════╕╒═══ cf_ops ══╕╒═══════ ld_ops ═══════╕╒═ hd_ops ╕╒═ ctx ══╕╒═ loop ═╕
//   0    1    2    3    4    5    6    7    8    9    10   11   12   13   14   15   ..   ..   ..
// ├────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┤

const NUM_CF_OP_BITS        : usize = 3;
const NUM_LD_OP_BITS        : usize = 5;
const NUM_HD_OP_BITS        : usize = 2;

const NUM_CF_OPS            : usize = 8;
const NUM_LD_OPS            : usize = 32;
const NUM_HD_OPS            : usize = 4;

const OP_COUNTER_IDX        : usize = 0;
const SPONGE_RANGE          : Range<usize> = Range { start:  1, end:  5 };
const CF_OP_BITS_RANGE      : Range<usize> = Range { start:  5, end:  8 };
const LD_OP_BITS_RANGE      : Range<usize> = Range { start:  8, end: 13 };
const HD_OP_BITS_RANGE      : Range<usize> = Range { start: 13, end: 15 };

// STACK LAYOUT
// ------------------------------------------------------------------------------------------------
//
// ╒═══════════════════ user registers ════════════════════════╕
//    0      1    2    .................................    31
// ├─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┤

pub const MAX_PUBLIC_INPUTS : usize = 8;
pub const MAX_OUTPUTS       : usize = MAX_PUBLIC_INPUTS;
pub const MAX_STACK_DEPTH   : usize = 32;